<html>
<head>
	<title>TeleHash - Edge Based Event Streams</title>
	<style>
	#bod {
		font-family:American Typewriter;
		font-weight:200;
		margin-left:300px;
	}
	h1 {
		font-weight:200;
		font-size:42pt;
		text-align:center;
	}
	#s {
		font-size:32pt;
		color:white;
	}
	#menu {
		position:fixed;
		top:10px;
		left:10px;
	}
	#hash {
		position:fixed;
		top:165px;
		left:18px;
		font-family:American Typewriter;
		color:white;
		font-size:9pt;
	}
	#menu li {
		font-family:American Typewriter;
		list-style-type:none;
		padding-left:10px;
		font-weight:200;
		font-size:18pt;
	}
	#menu a {
		font-size:24pt;
		color:black;
		text-decoration:none;
	}
	#menu a:hover {
		color:black;
		text-decoration:underline;
	}
	h3 {
		margin-top:-35px;
		text-align:center;
	}
	p,ul {
		font-family:Verdana;
		padding-left:10px;
	}
	big {
		color:#446;
		font-family:American Typewriter;
	}
	</style>
</head>
<body background="bg.gif">
<div id="menu">
	<img src="http://jeremie.com/i/810c8079d4a77e514296b3a58710c903.png"/><br/>
	<li>&#x260E; <a href="#about">ABOUT</a></li>
	<li>&#x260E; <a href="#spec">SPEC</a></li>
	<li>&#x260E; <a href="#code">CODE</a></li>
	<li>&#x260E; <a href="#who">WHO</a></li>
</div>
<div id="hash">eaffb349b9fa33a23eaf1bf1d9913cef94f1b057</div>
<div id="bod">
	<h1>TeleHa<span id="s">&#x26A1;</span>h</h1>
	<h3>Edge Based Event Streams</h3>

<a name="about"><h2>About</h2></a>

<p>TeleHash is a distributed network and open protocol for relaying web-centric events between in a real-time and fully decentralized manner.  Essentially, any kind of event occurring about, within, or in relation to any web page can be shared or observed.  TeleHash is adjacent to the web, adding a new channel and new dimension to every site in a radically open platform that is operated and owned purely by the users.
	
<p>It works by having everyone who is participating sharing part of the workload of detecting and distributing events, usually from within their web browser or desktop.  When an event happens locally it is announced to the network, and when events of interest happen they will be routed back locally for processing or display to the user.
	
<p>Everything within TeleHash revolves around one or more hashes, usually of a URL or some fragment of content on a page and its relationships.  Events that occur can include when pages have content added or updated (like twitter/feed urls), when comments are added, where visitors are arriving from or departing to, the presence of friends, or any conceivable activity or notification in relation to one or more pages.
</a>

<a name="spec"><h2>Spec</h2></a>
<p>WARNING: pre-draft state!
<p>
<p>Lexicon:
<ul><blockquote>
<li>		<big>writer</big> - every telehash node is a writer, guid formed from sha1(ip:port)
<li>		<big>telex</big> - each packet, contains one or more commands, signals, or variables
<li>		<big>signal</big> - (starts alphanumeric) a generic name/value pair relevant to an end, payload
<li>		<big>command</big> - (starts with a .) an instruction or direction of what action to take
<li>		<big>variable</big> - (starts with a _) a name/value pair local to a telex
<li>		<big>end</big> - the primary hash value representing where the telex is directed to 
<li>		<big>line</big> - active relationship between two writers
<li>		<big>dial</big> - to seek a writer to send signals/commands to, a multi-step process approaching the end
<li>		<big>listen</big> - to be registered on another writer that will forward certain signals when they arrive
</blockquote></ul>

<p>
<pre>
	// telex with example vars/sigs/cmds
	{
		"_at":1262027120,
		"_line":43723459,
		"end":"a9993e364706816aba3e25717850c26c9cd0d89d",
		"foo":"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33",
		".nat":"4.4.4.4:4444",
		".see":["5.6.7.8:23456","11.22.33.44:112233"],
		".fwd":{"foo":10,"bar":5}
	}
</pre>


<p>		Every node is called a Writer, which is any process listening on an IP and UDP port both sending and receiving packets from that port.  A Writer is positioned within the DHT by the SHA1 of their IP:PORT.

<p>		A Telex is any individual UDP packet sent to or by any Writer.  It's raw contents are a single plain UTF-8 JSON object containing one or more commands, variables, or signals.


<p>	Basics, contents of any Telex:

<ul><blockquote>
		_* - Variables
<blockquote>
<li>			<big>_to</big> - The public IP:PORT that the Telex was sent to (helps with NATs)
<li>			<big>_ring</big> - Used to open a line with a writer, value from 1 to 32768
<li>			<big>_line</big> - The private unique id of the line from one writer to another, the product of the _ring from both
</blockquote>
		.* - Commands
<blockquote>
<li>			<big>.see</big> - An array of writers (IP:PORT) that the recipient may find useful
<li>			<big>.natr</big> - An IP:PORT value, requesting the recipient to send a .nat command to that IP:PORT with senders IP:PORT (poke holes in NATs)
<li>			<big>.nat</big> - An IP:PORT to send a telex to, in order to open up a tunnel between them through any NAT devices
<li>			<big>.fwd</big> - An object with signals as names and integer values representing how many matching signal telexes to forward
<li>			<big>.fwds</big> - Same object sent anytime to show current status of active forwards on a writer for the requester
<li>			<big>.hist</big> - Same object format, but send up to that many historical matching telexes
<li>			<big>.stat</big> - TBD, request statistics on matching signals
</blockquote>
		alnum* - Signals, application specific, payload specific to an end
<blockquote>
<li>			<big>end</big> - [primary] The SHA1 hash value that the telex is directed towards
<li>			<big>at</big> - [common] GMT epoch timestamp of when any peer signals were created
<li>			<big>href</big> - [example] The SHA1 of the HREF clicked on (end is SHA1 of current page)
<li>			<big>from</big> - [example] The SHA1 of the previous page (end is the SHA1 of the new page)
<li>			<big>etag</big> - [example] The value of the etag header (end is current page)
<li>			<big>cht</big> - [example] The Content-Hash-Tree calculation of the current page
</blockquote>
</blockquote></ul>

<h2>	Common Patterns</h2>

<p>		<big>end .see</big> - Dialing (routing): Whenever a Telex comes in with a end, check to see if any closer Writers are known and if so .see back to that Writer a list of closer IP:PORTs.  If none are closer or if that end is the more popular of ones we've seen (congestion control), .see back only ourselves.

<p>		<big>end .fwd .fwds</big> - Listening: To observe signals coming in around an interesting end, first try dialing it in order to discover the closest Writers we can find.  Then send an end and .fwd of which signals to observe to those Writers, who if willing will respond with a .fwds to confirm that it's active.  Any Writer can process any .fwd request, and should check every incoming signal to see if it matches any active listener.

<p>		<big>end _to</big> - Startup: A Writer must have a cache or seed list of other Writers to bootstrap from.  It would first reach out to a few of them sending a random end that they would respond with a _to informing it of its visible public IP:PORT.  Then, it would Dial the SHA1 hash of that _to to start filling up its kbuckets (see Kademlia).  Use the _to for validation of future packets (EXPAND: how to handle different scenarios here).

<p>		<big>_ring _line</big> - Lines: Any Writers that want to have an ongoing relationship (proximity, listening, keeping a NAT open, etc) or for validating the other Writer's IP:PORT should establish a Line with them.  Both Writers at any point can send a _ring with a random number it assigns and stores for the other Writer. When either one receives a _ring it then starts sending a _line that is a product of the _ring it assigned and the one it received.  Any incoming _line can then be verified as being divisible by the assigned _ring to validate the other Writer.

<p>		<big>.nat .natr</big> - NATs: Whenever any Writer .see's new IP:PORT's to us, remember that it was them so that when trying to initiate the first Telex to that NEWIP:PORT we also send a ".natr":"NEWIP:PORT" (and _line) to the originating Writer.  That Writer then sends a ".nat":"OURIP:PORT" to them in case they are behind a NAT so that they will send a Telex out to us to ensure an open path of communication.

<h2>Notes</h2>

<p>For any incoming telex, once any _ring/_line is sorted out, a Writer then processes any commands (each is stateless and processed on their own).  If there is an end signal, it should cause a .see response of some sort, and possibly trigger caching this telex (for .hist processing) if the Writer is the closest.  Next, any and all contained signals should be checked against any active .fwd requests, and all matching .fwd Writers should get a copy of the telex.

<p>When an incoming {.fwd={sigA=5,sigB=10},sigC=foo} is received, it is registering to only receive telexes that contain a sigC=foo and any sigA or sigB signals (up to 5 or 10 times respectively).  This can be used for more complex selection and filtering.
	
<p>Signals should primarily only ever contain hashes or generic (like xpath) content references and never actual content, as the sending and recipient parties must both be independently aware of the context or content in question so as to avoid any injection or attract spamming from 3rd parties.

<p>The low level protocol is designed to be the absolute minimal to build connections and exchange notifications, all needs for peer trust, proxying, anonymizing, etc happen at a higher layer and outside of the basic protocol.
	
<a name="code"><h2>Code</h2></a>

<p>All code so far is avail via <a href="http://github.com/quartzjer/TeleHash">github</a>.

<p>A test node that will send back a _to to tell you your public IP and respond to end with a test .see is running at telehash.org:42424.
	
<a name="who"><h2>Who</h2></a>

<p>TeleHash is the culmination of years of discussions with many people, and is being primarily bootstrapped by <a href="http://jeremie.com/">Jeremie Miller</a>.  Feedback is welcomed via <a href="xmpp:jer@jabber.org">IM</a> until a wiki is set up here.


</div>
</html>
