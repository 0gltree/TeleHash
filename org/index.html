<html>
<head>
	<title>TeleHash - Decentralized JSON Notification Protocol</title>
	<style>
	#bod {
		font-family:American Typewriter;
		font-weight:200;
		margin-left:300px;
	}
	h1 {
		font-weight:200;
		font-size:42pt;
		text-align:center;
	}
	#s {
		font-size:32pt;
		color:white;
	}
	#menu {
		position:fixed;
		top:10px;
		left:10px;
	}
	#hash {
		position:fixed;
		top:165px;
		left:18px;
		font-family:American Typewriter;
		color:white;
		font-size:9pt;
	}
	#menu li {
		font-family:American Typewriter;
		list-style-type:none;
		padding-left:10px;
		font-weight:200;
		font-size:18pt;
	}
	#menu a {
		font-size:24pt;
		color:black;
		text-decoration:none;
	}
	#menu a:hover {
		color:black;
		text-decoration:underline;
	}
	h3 {
		margin-top:-35px;
		text-align:center;
	}
	p,ul {
		font-family:Verdana;
		padding-left:10px;
	}
	big {
		color:#446;
		font-family:American Typewriter;
	}
	</style>
</head>
<body background="bg.gif">
<div id="menu">
	<img src="http://jeremie.com/i/810c8079d4a77e514296b3a58710c903.png"/><br/>
	<li>&#x260E; <a href="#about">ABOUT</a></li>
	<li>&#x260E; <a href="#spec">SPEC</a></li>
	<li>&#x260E; <a href="#code">CODE</a></li>
	<li>&#x260E; <a href="#who">WHO</a></li>
</div>
<div id="hash">eaffb349b9fa33a23eaf1bf1d9913cef94f1b057</div>
<div id="bod">
	<h1>TeleHa<span id="s">&#x26A1;</span>h</h1>
	<h3>Decentralized JSON Notification Protocol</h3>

<a name="about"><h2>About</h2></a>

<p>TeleHash is an open distributed network protocol for relaying generic <a href="http://www.json.org/">JSON</a> notifications in a real-time and fully decentralized manner.  It is designed to efficiently route and distribute any kind of event occurring within or in relation to any application or piece of shared content.  The core benefits of TeleHash over other existing platforms and protocols is that it is both generic (not tied to any specific application or content structures) and is radically decentralized with no servers or points of central control.

<p>It works by having everyone who is participating sharing part of the workload of detecting and distributing events, usually from within their web browser or desktop/mobile application.  When an event is detected locally it is distributed intelligently into the network, and when events of interest happen they will be routed back locally for processing or display to the user.  This is accomplished by sending and receiving very simple small bits of JSON via <a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> using an easy routing system based on <a href="http://en.wikipedia.org/wiki/Kademlia">Kademlia</a>, a proven and popular <a href="http://en.wikipedia.org/wiki/Distributed_hash_table">Distributed Hash Table</a>.

<p>Everything within TeleHash revolves around one or more generic <a href="http://en.wikipedia.org/wiki/Hash_function">hashes</a>, usually of a URL or some fragment of content and its relationships.  Examples of some web-centric events include when pages have content added or updated (like twitter/feed urls), when comments are added, links visitors are arriving from or departing to, the presence of friends, or any conceivable activity or notification in relation to one or more pages.

<p>While it is still young, the protocol and early implementations are evolving quickly and can already be used to distribute events. Everyone is welcome to start experimenting and get involved in any form.
</a>

<a name="spec"><h2>Spec</h2></a>
<p>WARNING: pardon the formatting and terseness, draft state!
<p>
<p>Lexicon:
<ul><blockquote>
<li>		<big>Writer</big> - every telehash node is a writer, it's guid formed from sha1(ip:port)
<li>		<big>Telex</big> - each packet, contains one or more commands, signals, or variables
<li>		<big>Signal</big> - (starts alphanumeric) a generic name/value pair relevant to an end, payload, always string value
<li>		<big>Command</big> - (starts with a .) an instruction or direction of what action to take
<li>		<big>Variable</big> - (starts with a _) a name/value pair local to a telex
<li>		<big>End</big> - the primary hash value representing where the telex is directed to 
<li>		<big>Line</big> - active relationship between two writers
<li>		<big>Dial</big> - to seek a writer to send signals/commands to, a multi-step process approaching the end
<li>		<big>Listen</big> - to be registered on another writer that will forward certain signals when they arrive
</blockquote></ul>

<p>
<pre>
	// basic telex with example command
	{
		"_ring":43723,
		".see":["5.6.7.8:23456","11.22.33.44:11223"],
	}

	// telex with example signals
	{
		"end":"a9993e364706816aba3e25717850c26c9cd0d89d",
		"foo":"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33",
	}
</pre>


<p>		Every node is called a Writer, which is any process listening on an IP and UDP port both sending and receiving packets from that port.  A Writer is positioned within the DHT by the SHA1 of their IP:PORT.

<p>		A Telex is any individual UDP packet sent to or by any Writer.  It's raw contents are a single plain UTF-8 JSON object containing one or more commands, variables, or signals.


<p>	Basics, contents of any Telex:

<ul><blockquote>
		_* - Variables
<blockquote>
<li>			<big>_to</big> - The public IP:PORT that the Telex was sent to (helps with NATs)
<li>			<big>_ring</big> - Used to open a line with a writer, value from 1 to 32768
<li>			<big>_line</big> - The private unique id of the line from one writer to another, the product of the _ring from both
<li>			<big>_limbo</big> - Bytes sent are added, received are subtracted, current state (before this telex) is the value included. When the current value is over 10k all new telexes should stop/drop
<li>			<big>_seq</big> - Integer value from 0 to 4, incremented any time the Telex is forwarded
</blockquote>
		.* - Commands
<blockquote>
<li>			<big>.see</big> - An array of writers (IP:PORT) that the recipient may find useful
<li>			<big>.natr</big> - An IP:PORT value, requesting the recipient to send a .nat command to that IP:PORT with senders IP:PORT (poke holes in NATs)
<li>			<big>.nat</big> - An IP:PORT to send a telex to, in order to open up a tunnel between them through any NAT devices
<li>			<big>.fwd</big> - An array containing a list of filters that describe which telexes to match and forward back to the sender
<li>			<big>.fwds</big> - A response object mirroring the accepted .fwd values
</blockquote>
		alnum* - Signals, application specific, payload specific to an end
<blockquote>
<li>			<big>end</big> - [primary] The SHA1 hash value that the telex is directed towards
<li>			<big>href</big> - [example] The SHA1 of the HREF clicked on (end is SHA1 of current page)
<li>			<big>from</big> - [example] The SHA1 of the previous page (end is the SHA1 of the new page)
<li>			<big>etag</big> - [example] The value of the etag header (end is current page)
<li>			<big>cht</big> - [example] The Content-Hash-Tree calculation of the current page
</blockquote>
</blockquote></ul>

<h2>	Common Patterns</h2>

<p>		<big>end .see</big> - Dialing (routing): Whenever a Telex comes in with a end, check to see if any closer Writers are known and if so .see back to that Writer a list of closer IP:PORTs.  If none are closer or if that end is the more popular of ones we've seen (congestion control), .see back only ourselves.

<p>		<big>.fwd</big> - Listening: To observe signals coming in around an interesting end, first try dialing it in order to discover the closest Writers we can find.  Then send a .fwd of which signals to observe to those Writers close to the end, who if willing will respond with a .fwds to confirm that it's active.  Any Writer can process any .fwd request, and should check every incoming signal to see if it matches any listener with an active line.
<pre>
		// telex with example forward request
		{
			"_line":43723459,
			".fwd":
			[
				{"is":{ "end":"a9993e364706816aba3e25717850c26c9cd0d89d" }, "has":[ "foo" ] },
				{"is":{ "foo":"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33" } },
				{"has":[ "foo", "bar" ] },
			]
		}
</pre>


<p>		<big>end _to</big> - Startup: A Writer must have a cache or seed list of other Writers to bootstrap from.  It would first reach out to a few of them sending a random end that they would respond with a _to informing it of its visible public IP:PORT.  Then, it would Dial the SHA1 hash of that _to to start filling up its kbuckets (see Kademlia).  Use the _to for validation of future packets (EXPAND: how to handle different scenarios here).

<p>		<big>_ring _line</big> - Lines: Any Writers that want to have an ongoing relationship (proximity, listening, keeping a NAT open, etc) or for validating the other Writer's IP:PORT should establish a Line with them.  Both Writers at any point can send a _ring with a random number it assigns and stores for the other Writer. When either one receives a _ring it then starts sending a _line that is a product of the _ring it assigned and the one it received.  Any incoming _line can then be verified as being divisible by the assigned _ring to validate the other Writer.

<p>		<big>.nat .natr</big> - NATs: Whenever any Writer .see's new IP:PORT's to us, remember that it was them so that when trying to initiate the first Telex to that NEWIP:PORT we also send a ".natr":"NEWIP:PORT" (and _line) to the originating Writer.  That Writer then sends a ".nat":"OURIP:PORT" to them in case they are behind a NAT so that they will send a Telex out to us to ensure an open path of communication.

<h2>Notes</h2>

<!-- AKA command/var? Allow more hash ids of a writer derived from internal 10. 192. etc IPs? -->

<p>For any incoming telex, once any _ring/_line is sorted out, a Writer then processes any commands (each is stateless and processed on their own).  If there is an end signal, it should cause a .see response of some sort (unless there's a _seq > 0).  Next, if the _seq is less than 4, any and all contained signals should be checked against any active .fwd filters, and all matching .fwd Writers should get a copy of the telex with the _seq incremented.

<p>Signals should primarily only ever contain hashes or generic (like xpath) content references and never actual content, as the sending and recipient parties must both be independently aware of the context or content in question so as to avoid any injection or attract spamming from 3rd parties.

<p>The low level protocol is designed to be the absolute minimal to build connections and exchange notifications, all needs for peer trust, proxying, anonymizing, etc happen at a higher layer and outside of the basic protocol.

<h2>Writer Implementations</h2>

<p>There is a few different common levels of support a Writer can implement, from the most ultra-simple to a full Writer:
	<ul><blockquote>
		<li>Announcer - Only dials and sends signals, doesn't process any commands other than .see and doesn't send any _ring, possibly short-lived, can send signals.
		<li>Listener - Stays running, also supports returning basic _ring/_line/_limbo so that it can send .fwd commands in order to receive new signals, but processes no other commands.
		<li>Friendly - Will send a _to and seed itself and track other writers in order to respond to end signals, also supports .nat[r] commands, but doesn't process any signals or any .fwd commands.
		<li>Full - Supports all commands and relaying to any active .fwd filter.
	</blockquote></ul>

<p>Friendly/Full Writers need to implement seeding, keeping lines open, a basic bucketing system that tracks active Writers at different distances from themselves.

<p>The _limbo var is important to any long-lived Writer to prevent sudden flooding and to control bandwidth rates.  For each outgoing Telex the recipient Writer would have a local limbo count for how many bytes were sent to it, and when incoming Telexes come back that should balance out.  The most it can grow to is 10k, preventing any more data than that from being sent without an answer.  When incoming telexes from many Writers all have a high _limbo then it's an indicator of packet loss or backlog to the local Writer.  If there is expected to be a higher than 10k amount of bandwidth needed between two Writers, the _limbo can be intentionally set to a larger negative number to increase that allowed buffer between them.
	
<p>The ideology of vars/cmds/sigs is as such: A _variable can be of any type and it's purpose is to convey information about that single instance of a Telex and the state of a connection between Writers, meant to only carry extra information about the exchange, meta/headers, it is never meant to be used by any application or persisted/relayed.  A .command also can have any type of value and it's intended to cause an action on the recipient involving it's value and optionally including any signals in the same telex, also never to be relayed/persisted, private between Writers and open for applications to use custom commands to talk directly to each other.  A signal is always a string value usually relating to or from an application and is always considered public, possibly persisted and relayed to other Writers, and should only be used to convey information that may be of interest to an unknown or more than one party, discovery/announcements.
	
<a name="code"><h2>Code</h2></a>

<p>All code so far is avail via <a href="http://github.com/quartzjer/TeleHash">github</a>.

<p>A test node that will send back a _to to tell you your public IP and respond to end with a test .see is running at telehash.org:42424.
	
<a name="who"><h2>Who</h2></a>

<p>TeleHash is the culmination of years of discussions with many people, and is being primarily bootstrapped by <a href="http://jeremie.com/">Jeremie Miller</a>.  Feedback is welcomed via <a href="xmpp:jer@jabber.org">IM</a> until a wiki is set up here.


</div>
</html>
